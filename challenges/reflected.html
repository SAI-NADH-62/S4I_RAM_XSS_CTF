<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Reflected - XSS CTF</title>
  <link rel="stylesheet" href="/assets/style.css">
  <style>
    main { max-width:900px; margin:2rem auto; padding:1rem; }
    .vuln-box { background: rgba(255,255,255,0.02); padding:1rem; border-radius:10px; border:1px solid rgba(255,255,255,0.03); }
    .input-row { display:flex; gap:8px; margin:0.75rem 0; align-items:center; }
    input.msg { flex:1; padding:8px 10px; border-radius:8px; border:1px solid rgba(255,255,255,0.04); background:transparent; color:inherit; }
    button.go { padding:8px 12px; border-radius:8px; border:none; background: linear-gradient(90deg,#e11d48,#ff6b8a); color:#fff; font-weight:600; }
    .hint { color: #9aa6b2; font-size:0.9rem; margin-top:0.6rem; }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <div class="brand"><strong>XSS</strong> CTF <span class="tag">reflected</span></div>
      <nav class="top-nav"><a href="/index.html">Home</a></nav>
    </div>
  </header>

  <main>
    <div class="container">
      <h1>Reflected XSS </h1>
      <p class="lead">
        This version of the Reflected XSS lab demonstrates how to properly escape user input
        to prevent script execution. Try typing HTML or JavaScript - it will render safely as text.
      </p>

      <div class="vuln-box">
        <div class="input-row">
          <input id="payload" class="msg" placeholder='Hello, I am Iron Man' />
          <button id="apply" class="go">Apply</button>
        </div>

        <div id="msg">Message: <em>nothing yet</em></div>
        <div class="hint">Input will be reflected safely without executing scripts.</div>
      </div>
    </div>
  </main>

  <footer class="site-footer">
    <div class="container">
      <small>CTF lab - intentional vulnerabilities only </small>
    </div>
  </footer>

  <script>
    const input = document.getElementById('payload');
    const applyBtn = document.getElementById('apply');
    const container = document.getElementById('msg');

    // Safely update URL parameter
    function updateUrlMsg(value) {
      const newSearch = value ? '?msg=' + encodeURIComponent(value) : '';
      const newUrl = location.pathname + newSearch + location.hash;
      history.replaceState(null, '', newUrl);
    }

    // Vulnerable injection function (intentionally unsafe)
    function injectMessage(value) {
      // Note: vulnerable on purpose — we set innerHTML directly
      container.innerHTML = 'Message: ' + value;
      // After injection, check for injected script nodes / attributes
      checkAndClaim();
    }

    // Claim function — posts token to /api/claim
    async function claimFlag(challengeName) {
      if (window._ctf_claimed) return;
      window._ctf_claimed = true;
      try {
        const resp = await fetch('/api/claim', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token: window.ctf_token || null, challenge: challengeName })
        });
        if (!resp.ok) {
          const err = await resp.json().catch(()=>({ error: 'unknown' }));
          alert('Claim failed: ' + (err.error || resp.status));
          return;
        }
        const json = await resp.json();
        alert('FLAG: ' + json.flag);
      } catch (e) {
        alert('Error contacting /api/claim: ' + e.message);
      }
    }

    // Detect injected <script> nodes and trigger claim (wait briefly to let injected code run)
    function checkAndClaim() {
      if (window._ctf_claimed) return;

      // 1) SCRIPTS: require script to have substantive content or a src attribute.
      const scripts = container.querySelectorAll('script');
      for (let s of scripts) {
        const hasSrc = !!(s.src && s.src.trim().length > 0);
        const hasContent = !!(s.textContent && s.textContent.trim().length > 0);
        if (hasSrc || hasContent) {
          // found a real script with code or external src — consider this a valid injection
          setTimeout(()=> claimFlag('REFLECTED'), 200);
          return;
        }
      }

      // 2) Event-handler attributes: only count if attribute value is non-empty
      const handlerSelector = '[onerror], [onload], [onclick], [onmouseover], [onfocus], [onmouseenter]';
      const withHandler = container.querySelectorAll(handlerSelector);
      for (let el of withHandler) {
        // check each possible attribute for meaningfully non-empty value
        const attrs = ['onerror','onload','onclick','onmouseover','onfocus','onmouseenter'];
        for (let a of attrs) {
          if (el.hasAttribute(a)) {
            const val = el.getAttribute(a);
            if (val && val.trim().length > 0) {
              setTimeout(()=> claimFlag('REFLECTED'), 200);
              return;
            }
          }
        }
      }

      // 3) <img src=x onerror=...> like handlers that might execute — already handled above,
      // but could add additional heuristics here if needed.

      // Otherwise: no substantive injection detected — do not claim.
    }

    // Initialize from URL (?msg=)
    (function initFromUrl() {
      const params = new URLSearchParams(location.search);
      const msg = params.get('msg') || '';
      if (msg) {
        input.value = msg;
        injectMessage(msg);
      } else {
        injectMessage('');
      }
    })();

    // Live update (debounced)
    let debounceTimer = null;
    input.addEventListener('input', (e) => {
      const val = e.target.value;
      updateUrlMsg(val);
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(()=> injectMessage(val), 120);
    });

    applyBtn.addEventListener('click', ()=> {
      const val = input.value;
      updateUrlMsg(val);
      injectMessage(val);
      input.focus();
    });

    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        applyBtn.click();
      }
    });
  </script>
</body>
</html>
